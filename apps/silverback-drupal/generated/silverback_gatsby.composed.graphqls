"""
Apply all directives on the right to output on the left.
"""
directive @map on FIELD_DEFINITION

"""
Mark a type as member of a generic.
The id argument contains a string that has to match the generics resolution.
"""
directive @type(id: String!) on OBJECT

"""
Provide a static value as JSON string.

Provided by the "graphql_directives" module.
Implemented in "Drupal\graphql_directives\Plugin\GraphQL\Directive\Value".
"""
directive @value(json: String!) on FIELD_DEFINITION | UNION | INTERFACE

"""
Seek a specific element in a list.

Provided by the "graphql_directives" module.
Implemented in "Drupal\graphql_directives\Plugin\GraphQL\Directive\Seek".
"""
directive @seek(pos: Int!) on FIELD_DEFINITION | UNION | INTERFACE

"""
Retrieve an object or map property.

Provided by the "graphql_directives" module.
Implemented in "Drupal\graphql_directives\Plugin\GraphQL\Directive\Prop".
"""
directive @prop(key: String!) on FIELD_DEFINITION | UNION | INTERFACE

type Schema {
  query: Query
}

type Query

type Feed {
  typeName: String! @prop(key: "typeName")
  translatable: Boolean! @prop(key: "translatable")
  singleFieldName: String! @prop(key: "singleFieldName")
  listFieldName: String! @prop(key: "listFieldName")
  changes(lastBuild: Int, currentBuild: Int): [String!]! @prop(key: "changes")
  pathFieldName: String @prop(key: "pathFieldName")
  templateFieldName: String @prop(key: "templateFieldName")
}

directive @isPath on FIELD_DEFINITION

"""
DEPRECATED, use @isPath
"""
directive @path on FIELD_DEFINITION

directive @isTemplate on FIELD_DEFINITION

"""
DEPRECATED, use @isTemplate
"""
directive @template on FIELD_DEFINITION

directive @resolveEntityPath on FIELD_DEFINITION

directive @resolveProperty(path: String!) on FIELD_DEFINITION

"""
DEPRECATED, use @resolveProperty
"""
directive @property(path: String!) on FIELD_DEFINITION

directive @resolveEntityReference(field: String!, single: Boolean!) on FIELD_DEFINITION

directive @resolveEntityReferenceRevisions(field: String!, single: Boolean!) on FIELD_DEFINITION

"""
Annotate a type to correspond to a editor block (e.g. Gutenberg)
"""
directive @editorBlock(
  """
  The block ID within the CMS.
  """
  type: String!
 on OBJECT

"""
Parse field content using the editor block parser.
"""
directive @resolveEditorBlocks(
  """
  The property path to resolve the HTML content blog within the current entity.
  """
  path: String!
  """
  List of block types that don't contribute to the document and will be ignored.
  If an ignored block has children, they are flattened into the list of blocks.
  "core/group" is ignored by default.
  """
  ignore: [String!]
  """
  List of block types that are treated like plain HTML without attributes, just
  as "core/paragraph". Sequences of these blocks will be aggregated into a
  single instance of "core/paragraph".
  """
  aggregate: [String!]
 on FIELD_DEFINITION

"""
Resolve an attribute value on a block.

* "markup": resolve the blocks inner html content as string
* "children": resolves the blocks inner blocks as array of blocks
* "media": a media item, related to that block
* ... anything else will resolve the blocks attribute as string
"""
directive @resolveEditorBlockAttribute(name: String!) on FIELD_DEFINITION

directive @entity(type: String!, bundle: String, access: Boolean) on OBJECT

directive @menu(
  """
  The internal menu id.
  """
  menu_id: String
  """
  Internal menu id's. The first one the current user has access to will be
  picked.
  """
  menu_ids: [String!]
  """
  GraphQL type for menu items.
  
  **DEPRECATED**: Explicitly define Menu item types with `resolveMenu*`
  directives instead.
  """
  item_type: String
  """
  The maximum level to be fetched.
  This can be used to optimizing caching. Most of the time only one or two
  levels of menus are immediately visible on the page. By declaring multiple
  types, we can generate different cache buckets, so a new menu item on a low
  level does not require a full rebuild of every page.
  """
  max_level: Int
 on OBJECT

"""
Resolve menu items in a menu.
"""
directive @resolveMenuItems(
  """
  The maximum level to be fetched.
  This can be used to optimizing caching. Most of the time only one or two
  levels of menus are immediately visible on the page. By declaring multiple
  types, we can generate different cache buckets, so a new menu item on a low
  level does not require a full rebuild of every page.
  """
  max_level: Int
 on FIELD_DEFINITION

"""
Resolve the menu items id.
"""
directive @resolveMenuItemId on FIELD_DEFINITION

"""
Resolve the menu item parents id.
"""
directive @resolveMenuItemParentId on FIELD_DEFINITION

"""
Resolve a menu items label.
"""
directive @resolveMenuItemLabel on FIELD_DEFINITION

"""
Resolve the Url from within a menu item.
"""
directive @resolveMenuItemUrl on FIELD_DEFINITION

directive @stringTranslation(contextPrefix: String) on OBJECT
